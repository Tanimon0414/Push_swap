## t_command 構造体
（特にその中の all メンバ）は、あるノードを特定の状態に動かすための一連の操作（回転やプッシュ）にかかる総コスト（総手数）を算出し、複数の候補となる手筋のコストを比較検討するために用いられます。

アルゴリズムは、以下のような流れで t_command を利用することが一般的です。

候補の洗い出し: スタックAからスタックBへどのノードを移動させるか、あるいはスタック内でどのようにノードを配置し直すか、いくつかの候補となる手筋を考えます。

コスト計算: それぞれの手筋について、必要な ra, rra, rb, rrb などの回転操作の回数を計算します。

最適化: 可能であれば rr や rrr を用いて共通の回転をまとめ、手数を削減します。
<!-- （ご指摘の点は、push_swapのアルゴリズムを考える上で非常に重要なポイントです。ra と rb を rr に、あるいは rra と rrb を rrr に最適化する際、「どの操作をどの順番で行うか」という計画が必要になりますね。

しかし、多くの場合、push_swap のアルゴリズムでは、具体的な操作の長いシーケンスを事前に全て文字列やリストとしてメモリに格納し、後からそのシーケンスを書き換えて最適化する、という手法を必ずしも取るわけではありません。

代わりに、以下のようなアプローチで「操作の順番」と「最適化」を扱います。

目標とコスト計算:

まず、「スタックAのこのノードを、スタックBのあの位置に持っていきたい」といった短期的な目標を定めます。
その目標を達成するために、スタックAで必要な回転（raまたはrra）の回数と、スタックBで必要な回転（rbまたはrrb）の回数を計算します。
最適化された回数の算出:

例えば、スタックAを上に3回回転（ra 3回）、スタックBを上に2回回転（rb 2回）させる必要があると計算されたとします。
この時点で、「raとrbが隣り合っているか」をシーケンス上で探すのではなく、**「同時に実行できる回転は最大何回か」**を考えます。この例では、rr（raとrbを同時に行う）を2回実行できる、となります。
そして、残りの必要な回転は ra 1回となります。
この結果（rrを2回、raを1回、そして最後にプッシュ操作1回）を、t_command構造体に格納します。例えば、t_command.rr = 2、t_command.ra = 1、t_command.rb = 0 のように、最終的に実行すべき各操作の回数として記録します。
t_commandへの格納:

t_command構造体の各メンバ（ra, rra, rb, rrb, rr, rrr）には、上記のように最適化を考慮した上で、**これから実行すべき個別の操作の「回数」**が格納されます。
t_command.allには、これらの回数とプッシュ/スワップ操作の回数を合計した総手数が格納されます。
操作の実行順序:

最もコストの低い（t_command.allが最小の）手筋が選ばれたら、そのt_commandに格納された回数に基づいて実際の操作を行います。
このとき、操作の出力順序は、ある程度決まったパターンになります。例えば、
まず rr や rrr を指定回数実行する。
次に、残りの片方のスタックのみの回転（ra, rra, rb, rrb）を指定回数実行する。
最後に、プッシュ操作（pa や pb）やスワップ操作を実行する。
このように、具体的な操作列を事前に長く保持するのではなく、「どの種類の操作を、何回行うか」という計画をt_commandで管理し、その計画に基づいて一定の順序で操作を出力・実行する形になります。） -->

総コスト算出: 上記の回転操作の回数と、必要であればプッシュ操作（pa または pb で1手）の回数を合計し、その手筋の総コストを t_command の all メンバなどに格納します。この際、ra, rra などのメンバには、最適化後の個別の回転数や、最適化に使用した rr, rrr の回数が記録されることもあります。

比較と選択: 複数の手筋の t_command.all（総コスト）を比較し、最もコストの低い（手数の少ない）手筋を選択して実行します。

このように、t_command は単に各コマンドの回数を記録するだけでなく、どの一連の操作が最も効率的かを判断するための「評価値」や「計画」を保持する役割を担っていると言えます。それによって、最終的により少ない手数でソートを完了することを目指します。