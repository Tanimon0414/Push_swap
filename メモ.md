手法の全体的な流れについて
① 入力処理とエラー処理

引数の受け取り方（argv[1] = "1" など）とエラー処理（引数なし、数字以外）はsubjectの指示通りで問題ないでしょう。
② stackAへの格納

argv[1]がスタックの先頭（top）になるように格納する点は、subjectの「The first argument should be at the top of the stack」という指示に合致しています。 
③ Bに先頭から2つ送る

これは初期戦略として、Aの要素数を減らしつつ、Bである程度の基準を作るためでしょうか。具体的な目的や、この2つの要素の選び方に基準があれば教えてください。（例：とりあえず2つ送る、特定の条件の2つを送るなど）
④ AからBへの要素移動戦略 (Aが3つになるまで)

候補の選定: スタックAの上から、または下から近い順にBへ送る候補を選ぶというアイデアは、回転コストを意識した良い着眼点です。
コスト計算とrr/rrrの活用: Aを回転させるコストとBを回転させるコストを計算し、同じ方向の回転であれば rr や rrr を使って手数を圧縮するというのは、最適化において非常に重要です。これがアルゴリズムの核となる部分ですね。各候補に対してこの最小コストを計算し、最も手数の少ないものを実行するという戦略は合理的です。
⑤ Aのソート (残り3つの要素)

要素数が3つになった時点でAをソートするのは、非常に少ない手数で確実に行えるため、良い区切り方です。この3つの要素のソートは、最大でも2手（例：sa, rraなど、組み合わせによる）で完了できます。
⑥ BからAへの戻し戦略

Bの要素をAに戻す際にも、Aを適切に回転させながら正しい位置に挿入していく必要がありますね。Bのどの要素を次にAに戻すか（例：Bの最大値をAの適切な位置へ、など）、そしてAをどのように回転させるかのコスト計算がここでも重要になります。
データ構造について
双方向連結循環リスト (s_node, s_stack)

スタック操作（特に回転 ra, rra, rb, rrb）の効率を考えると、双方向連結循環リストは非常に良い選択です。 

s_node に data (数値)、index (ソート後の順位、後述の戦略で活用できそうですね)、command (後述)、next, prev を持たせるのは適切です。
s_stack が top のみを保持するのも一般的です。循環リストなので top->prev で末尾要素にもアクセスできます。
コマンド構造体 (s_command)

s_command で各要素を移動させるためのコマンド数 (ra, rra, rb, rrb, rr, rrr) と総手数 (all) を保持するアイデアは、④のコスト計算と最適コマンド選択の際に非常に役立ちます。各要素に対して、このコマンド情報を計算・保存し、比較することで最適な移動を選択できます。
ダミーポインタの導入について

<!-- 「先頭にダミーポインタを1つ用意します。リストの終端判定や、空リストの維持に役立ちます。」というアイデアについてですね。これはセンティネルノード (sentinel node) や番兵とも呼ばれるテクニックです。
メリット:
リストが空の場合の処理や、リストの先頭・末尾への要素追加・削除の際のNULLチェックが減り、コードがシンプルになる場合があります。例えば、常にダミーノードが存在するので、「リストが空かどうか」を top == NULL ではなく top == dummy_node && top->next == dummy_node (あるいは dummy_node->next == dummy_node) のように判定できます。
要素が1つの場合の回転操作なども、ダミーノードがあることで境界条件の処理が少し楽になることがあります。
実装例の解釈: ... 3 ⇔ [ダミー0] ⇔ 1 ⇔ 2 ⇔ 3 ⇔ [ダミー0]... この図ですと、ダミーノードがリストの「起点」であり「終点」でもあるようなイメージですね。top がこのダミーノードを指し、実際の最初の要素は dummy_node->next、最後の要素は dummy_node->prev となります。 -->
s_dlst と s_node: ご提示の s_dlst は value, next, prev を持っており、これはご自身の s_node（data, index, command, next, prev を持つ）と役割が似ています。ダミーノードも同じ構造体型 s_node (または s_dlst) を使って作成します。ダミーノードの data や index などの値は特別な意味を持たない値（例：0や-1）にしておくと良いでしょう。
導入の判断: 必ずしも必須ではありませんが、実装によってはコードを簡潔にできる場合があります。もし境界条件の処理で苦労するようなら、導入を検討する価値はあります。最初はダミーなしで実装してみて、必要性を感じたらリファクタリングで導入するのも一つの手です。
細かい確認点とアドバイス
s_node の index: この index フィールドは、入力された数値がソートされた場合に取るべき最終的な順位（0から始まるインデックスなど）を事前に計算して格納しておくためのものでしょうか。もしそうであれば、この index を基準にBからAへ戻す際の戦略や、Aに残す要素の選定などに活用できるため非常に有効です。
エラー処理「重複」: subjectにはエラー処理として「some arguments not being integers, some arguments exceeding the integer limits, and/or the presence of duplicates.」とあります。  現在の計画には「重複」のチェックが含まれていないように見受けられますので、追加をご検討ください。
A1, A2, A3 (特定ケースの最適化):
sort済み引数(0,1,2,3,4,5,6,...,)は、手数0: これは、入力が既にソート済みの場合、何も操作を表示しないということです。プログラムの最初（またはスタック構築後）にソート済みかチェックする処理を入れると対応できます。
引数3で3手以下, 引数5で12手以下: これらは、要素数が少ない場合の最大手数の目安ですね。特に要素数3の場合は、最大でも2手でソート可能です（例：2 1 0 -> sa, rra で 0 1 2）。要素数5の場合は、ご自身のアルゴリズムでこの手数を目指す、あるいは特定のパターンをハードコーディングする戦略も考えられます。ただし、汎用的なアルゴリズムで12手以下を達成するのが理想です。
Q. checkerのコマンド(ra, pbなど）はスペース飛ばし？ A. スペースも文字として認識させてください。: これは、checker プログラムが標準入力から受け取る操作コマンドのパースに関する指示だと思われます。 例えば、"ra\n" は有効なコマンドですが、"ra \n" や " ra\n" のようにコマンドの前後に余計なスペースが入っている場合、それをエラーとして扱うか、よしなに解釈するか、という点です。 「スペースも文字として認識させてください」という回答は、おそらく「予期せぬスペースはエラーとして扱う」か、「コマンド名自体にスペースが含まれることはないが、パース時に厳密に判定せよ」という意味合いが強いかもしれません。 ご自身の checker (ボーナス課題) を実装する際に、標準入力から1行ずつ read (または get_next_line など) で読み込み、読み込んだ文字列が "sa\n", "pb\n" など、定義されたコマンド文字列と完全に一致するかどうかを判定する、という実装になるでしょう。"sa" と SA_CHAR のようなマクロを strcmp する際に、改行文字も考慮に入れるかどうかも設計次第です。一般的には、改行を除いた部分で比較します。
まとめと次のステップ
全体的な戦略は非常によく考えられており、特にコスト計算による最適化の視点は重要です。

現時点で特に深掘りすると良さそうな点:

index の具体的な活用戦略: ソート後の順位をどのようにアルゴリズムに組み込むか。
BからAへ戻す際の詳細なロジック: Bのどの要素を次に選ぶか、Aのどこに挿入するか、その際の最小コスト計算。
要素数が少ない場合の処理: 3つの要素のソートは確実に行い、5つ以下の要素の場合に、汎用アルゴリズムがA3の基準を満たせるか、または特別な処理を入れるか。
もしよろしければ、これらの点についてさらに詳しく教えていただけますでしょうか。また、他に疑問点や具体的に詰まっている箇所があれば、遠慮なくお聞きください。